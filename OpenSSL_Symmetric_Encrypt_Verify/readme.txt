Assignment 2 hpy414 
////////////////////////////////////////////////
Amplianitis Konstantinos 
2017030014
///////////////////////////////////////////////

gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0


///////////////////////////////////////////////


the file will be separated in tasks and main.

All task have been completed.

////////////////////////////////////////////////
TASK A
////////////////////////////////////////////////

Key Derivation Function (KDF).

returns void.

Arguements: 
	unsigned char* password : the password given by the user
	unsigned char* key 	 : the array that will store the key generated by the function
	unsigned char* iv	 : Initialization vector
	int bit_mode 		 : the bit mode given (128, 256 supported)
	
Functionality:
	The function calls the EVP_BytesToKey (is in the evp.h lib). Then based on bit_mode (switch) uses either the EVP_aes_128_ecb() or EVP_aes_256_ecb() (also in evp.h) with no salt and count =1. It also used the sha1() which is included in the sha.h
	


////////////////////////////////////////////////
TASK B
////////////////////////////////////////////////


Encrypt function

returns the size of the cipher text

Arguements:
	unsigned char *plaintext  : The text that is going to be encrypted
	int plaintext_len 	   : The length of the paintext
	unsigned char *key	   : The key that the plaintext is going to be encrypted with
    	unsigned char *iv	   : Initialization vector
    	unsigned char *ciphertext : The vector which will store the encrypted text
    	int bit_mode		   : the bit mode given (128, 256 supported)
    	
Functionality:
	The function creates a ctx and through a switch, based on the bit mode, it encrypts the text with the EVP_aes_(bitmode)_ecb(). No salt and the arguements as arguments of the function. In the end it calculates the length of the cipher and returns it. (Functions used Encrypt_Init_ex, EncryptUpdate, EncryptFinal)

////////////////////////////////////////////////
TASK C
////////////////////////////////////////////////

Decrypt function

returns the size of the plaintext

Arguements:
	unsigned char *ciphertext  : The text that is going to be decrypted
	int ciphertext_len 	    : The length of the ciphertext
	unsigned char *key	    : The key that will be used to decrypt the cipher.
	unsigned char *iv 	    : Initialization vector
	unsigned char *plaintext   : The vector which will store the decryptd text
	int bit_mode		    : the bit mode given (128, 256 supported)
	
Functionality:
	Does the reverse functionality of the encrypt function.The function creates a ctx and through a switch, based on the bit mode, it decrypts the text with the EVP_aes_(bitmode)_ecb(). No salt and the arguements as arguments of the function. In the end it calculates the length of the cipher and returns it. (Functions used Decrypt_Init_ex, DecryptUpdate, DecryptFinal).
	
		
////////////////////////////////////////////////
TASK D
////////////////////////////////////////////////

Sign Process

I write the gen_cmac.

gen_cmac

	Arguements:
		unsigned char *data  : The data given as a plaintext
		size_t data_len      : The length of the data
		unsigned char *key   : The key that will generate the cmac with
		unsigned char *cmac  : The vector which will store the cmac
		int bit_mode         : The bit mode given (128, 256 supported)

Functionality:
	Creates a ctx. Then based on the bit mode calls the CMAC_Init with the equivalent EVP_aes_bit_mode_ecb() no engine. The size of the cmac depends also on the bit mode.(Functions used CMAC_Update, CMAC_Final).
	
	
////////////////////////////////////////////////
TASK E
////////////////////////////////////////////////
	
Verification process

verify_cmac

returns the result of the memcmp fucntion. (0 if cmacs are same , !0 if cmacs are different)
	Arguements:
		unsigned char *cmac1 : Cmac 1 
 		unsigned char *cmac2 : Cmac 2
 
 Functionality:
 	Calls a memcpm (cause both cmacs are unsigned char) and return the verify result. 0 if cmacs are same , !0 if cmacs are different.

////////////////////////////////////////////////
TASK F
////////////////////////////////////////////////


Use of the tool.


Functions that I created to help me:

InputFile_Read

return unsigned char*

Arguements:	
		char *input_file  : The name of the file that will be read
		int *file_len     : Length of the file after read

Functionality:
		Simply reads the file. With the use of file_size i calculate the length of the file





file_size

returns int

Arguements:
		FILE * : file pointer to the file that will return the size
		
Functionality:
		Uses fseek ftell to find the size of the file. In the end with fseek returns the pointer to the beginning.
		
		
Write_Data

returns void 

Arguements:
		char *            :  Name of the output file
		unsigned char *   :  The data that is going to get written
		int               :  Length of the data written

Functionality:
		Opens or creates the file named like the output file. Uses fwrite to write the data.

Functionality of the usage in main:

With a switch method (opcode as the arguement) I either encrypt, decrypt, sign or verify.

In case of opcode =0 (encrypt), with a simple function I made, I read the contents of the file and I return both the data and the length of the file. Then I dynamically allocate memory of datalen + 16 (cause of padding) and call the encrypt function. In the end I call a simple function I also created so that I write the encrypted text.




In case of opcode =1 (decrypt) I do almost the same procedure. I read the contents of the file and I return both the data and the length of the file. Then I dynamically allocate memory of datalen(no case of padding here) and call the decrypt function. In the end I call a simple function I also created so that I write the encrypted text.


In case of opcode =2 (sign) I do almost the same procedure as the encryption. The only difference is the addition of a memory allocation for the cmac and the call of the gen_cmac function. I also call a function to concatenate data and cmac to write it after in the file using the same writing function.


In case of opcode =3 (verify) after the read of the file I ditach the last 16 bytes which are the cmac of the file and I decrypt the rest. Then I call the gen_cmac function to create a cmac so I can compare the cmac that I detach earlier and the one that will be generated. If the cmacs are the same then the verify_cmac returns zero and the file is safe and the content can be written into a file. In any other case the file is declared unsafe and will not get written.

In the end I free all the arrays.

////////////////////////////////////////////////
RESULTS
////////////////////////////////////////////////
Notice that both the files used for verification will not get written. This is becaused they cannot be verified through the verify_cmac function.
